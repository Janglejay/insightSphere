---
tags: design-pattern
---
# 七大设计原则
### 开闭原则（Open Closed Principle，OCP）
> 对扩展开放，对修改关闭

问题：
软件生命周期中升级或者维护需要对旧代码进行修改，容易引入风险。
开闭原则是尽量减少旧代码修改的情况下进行扩展。
如何实现：
1. 使用抽象类或者接口对扩展的边界进行界定。
2. 引用对象使用抽象类或者接口。
3. 扩展时添加具体实现而不是改变具体方法。


### 单一职责原则（Single Responsibility Principle, SRP）
> 有且仅有一个原因引起类的变更 

1. 降低类的复杂性，明确定义类的职责
2. 降低变更引起的风险

### 里氏代换原则（Liskov Substitution Principle，LSP）
> 任何基类可以出现的地方，子类一定可以出现

问题：
1. 继承是侵入性的。子类就必须拥有父类的属性和方法。
2. 继承降低了代码的灵活性，子类会被父类约束。
3. 父类和子类是具有耦合性的，父类常量、变量、方法被修改时，需要考虑子类的修改。
实现：
1. 子类必须完全实现父类的方法。
2. 子类可以进行个性化的扩展。
3. 覆盖或实现父类的方法时，输入参数可以被放大。
4. 覆盖或实现父类的方法时，输出结果可以被缩小。

### 依赖倒转原则（Dependency Inversion Principle，DIP）
> 针对接口编程，依赖于抽象而不依赖于具体。
1. 模块间的依赖通过抽象发生，实现类之间不直接发生依赖关系，其依赖关系是通过接口或抽象类产生的。
2. 接口或抽象类不依赖于实现类洁。
3. 实现类依赖接口或抽象类。
实现：
1. 每个类尽量都有接口或抽象类，或者接口和抽象类两者都具备。
2. 变量的表面类型尽量是接口或抽象类。
3. 任何类都不应该从具体类派生。
4. 尽量不要重写基类的方法。如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要重写。
5. 结合里氏替换原则使用。

### 接口隔离原则（Interface Segregation Principle，ISP）
> 使用多个隔离的接口，比使用单个接口要好。

1. **客户端不应该被迫依赖于它不使用的方法**
2. **一个类对另一个类的依赖应该建立在最小的接口上**

与单一职责原则的区别:
1. 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
2. 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

### 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）
> 尽量使用合成/聚合的方式，而不是使用继承。

通常类的复用分为**继承复用**和**合成复用**两种。
继承复用:
优点：简单易实现
缺点：
1. 破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与
3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。
组合或聚合复用:
1. 维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。

### 最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of  Demeter，LOD）
> 一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

实现：
1. 只和朋友交流。
```ad-info
出现在成员变量、方法的输入输出参数中的类称为成员朋友类。
```
2. 朋友间也是有距离的
3. 是自己的就是自己的
```ad-info
如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。

```

### Referance
[设计模式简介](https://www.runoob.com/design-pattern/design-pattern-intro.html)
[七大设计模式](https://hjk.life/posts/design-patterns-principles/)
[六大设计模式](https://zhuanlan.zhihu.com/p/110130347)
